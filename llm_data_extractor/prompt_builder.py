"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/prompt_builder.ipynb.

# %% auto 0
__all__ = ['build_prompt']

# %% ../nbs/API/prompt_builder.ipynb 3
from typing import List, Dict
from .models import Question, AnswerType

# %% ../nbs/API/prompt_builder.ipynb 4
def build_prompt(questions: List[Question], source_text: str) -> str:
    """
    Build a structured prompt for LLM data extraction.
    
    Args:
        questions: List of Question objects to extract data for
        source_text: The unstructured text to extract data from
        
    Returns:
        Formatted prompt string
    """
    
    # Group questions by similarity or type for better processing
    grouped_questions = _group_questions(questions)
    
    prompt_parts = [
        "You are a data extraction assistant. Extract the requested information from the provided text.",
        "",
        "INSTRUCTIONS:",
        "- Answer each question precisely based only on the information in the text",
        "- If information is not available, respond with 'NULL'",
        "- Follow the exact format requirements for each question",
        "- Provide a confidence score (0.0-1.0) for each answer",
        "",
        "TEXT TO ANALYZE:",
        "---",
        source_text.strip(),
        "---",
        "",
        "QUESTIONS TO ANSWER:",
    ]
    
    for i, question in enumerate(questions, 1):
        question_block = [
            f"Question {i} (ID: {question.id}):",
            f"Q: {question.text}",
            f"Expected format: {_get_format_instruction(question)}",
            f"Response format: {{\"answer\": your_answer, \"confidence\": 0.0-1.0}}",
            ""
        ]
        prompt_parts.extend(question_block)
    
    prompt_parts.extend([
        "Respond with a JSON object containing all answers:",
        "{",
        '  "responses": [',
        '    {"question_id": "...", "answer": "...", "confidence": 0.0-1.0},',
        '    ...',
        "  ]",
        "}"
    ])
    
    return "\n".join(prompt_parts)


def _group_questions(questions: List[Question]) -> Dict[str, List[Question]]:
    """Group questions by group_key or similar characteristics."""
    groups = {}
    for question in questions:
        key = question.group_key or question.answer_type.value
        if key not in groups:
            groups[key] = []
        groups[key].append(question)
    return groups


def _get_format_instruction(question: Question) -> str:
    """Generate format instruction based on question type and constraints."""
    answer_type = question.answer_type
    constraints = question.constraints
    
    if answer_type == AnswerType.BOOLEAN:
        return "true or false"
    
    elif answer_type == AnswerType.ENUM:
        valid_values = constraints.get("valid_values", [])
        return f"One of: {', '.join(str(v) for v in valid_values)}"
    
    elif answer_type == AnswerType.INTEGER:
        min_val = constraints.get("min")
        max_val = constraints.get("max")
        if min_val is not None and max_val is not None:
            return f"Integer between {min_val} and {max_val}"
        elif min_val is not None:
            return f"Integer >= {min_val}"
        elif max_val is not None:
            return f"Integer <= {max_val}"
        else:
            return "Integer"
    
    elif answer_type == AnswerType.FLOAT:
        return "Decimal number"
    
    elif answer_type == AnswerType.DATE:
        date_format = constraints.get("format", "YYYY-MM-DD")
        return f"Date in format: {date_format}"
    
    elif answer_type == AnswerType.LIST:
        item_type = constraints.get("item_type", "string")
        return f"List of {item_type} values, comma-separated"
    
    else:  # STRING
        max_length = constraints.get("max_length")
        if max_length:
            return f"Text (max {max_length} characters)"
        return "Text"
